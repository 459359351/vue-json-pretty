<template>
  <div
    :class="{
      'vjs-tree': true,
      'is-mouseover': isMouseover,
      'has-selectable-control': showSelectController
    }"
    @mouseover.stop="handleMouseover"
    @mouseout.stop="handleMouseout"
  >
    <tree-node
      v-for="(item, index) in flatData"
      :key="index"
      :node="item"
      :collapsed="!!hiddenPaths[item.path]"
      :custom-value-formatter="customValueFormatter"
      :show-double-quotes="showDoubleQuotes"
      :show-length="showLength"
      :collapsed-on-click-brackets="collapsedOnClickBrackets"
      :checked="selectedPaths.includes(item.path)"
      :selectable-type="selectableType"
      :show-line="showLine"
      :show-select-controller="showSelectController"
      :select-on-click-node="selectOnClickNode"
      :path-selectable="pathSelectable"
      :highlight-mouseover-node="highlightMouseoverNode"
      :highlight-selected-node="highlightSelectedNode"
      @tree-node-click="onTreeNodeClick"
      @brackets-click="onBracketsClick"
      @selected-change="onSelectedChange"
    />
  </div>
</template>

<script>
  import TreeNode from 'src/components/TreeNode'
  import { getDataType, jsonFlatten } from 'src/utils'
  import './styles.less'

  export default {
    name: 'VueJsonPretty',
    components: {
      TreeNode,
    },
    props: {
      // 当前树的数据
      data: {
        type: [String, Number, Boolean, Array, Object],
        default: null
      },
      // 定义树的深度, 大于该深度的子树将不被展开
      deep: {
        type: Number,
        default: Infinity
      },
      // 数据层级顶级路径
      path: {
        type: String,
        default: 'root'
      },
      // 是否显示数组|对象的长度
      showLength: {
        type: Boolean,
        default: false
      },
      // key名是否显示双引号
      showDoubleQuotes: {
        type: Boolean,
        default: true
      },
      // 定义数据层级支持的选中方式, 默认无该功能
      selectableType: {
        type: String,
        default: '' // ''|multiple|single
      },
      // 是否展示左侧选择控件
      showSelectController: {
        type: Boolean,
        default: false
      },
      showLine: {
        type: Boolean,
        default: true
      },
      // 是否在点击树的时候选中节点
      selectOnClickNode: {
        type: Boolean,
        default: true
      },
      // 存在选择功能时, 定义已选中的数据层级
      //    多选时为数组['root.a', 'root.b'], 单选时为字符串'root.a'
      value: {
        type: [Array, String],
        default: () => ''
      },
      // 定义某个数据层级是否支持选中操作
      pathSelectable: {
        type: Function,
        default: () => true
      },
      // highlight current node when mouseover
      highlightMouseoverNode: {
        type: Boolean,
        default: false
      },
      // highlight current node when checked
      highlightSelectedNode: {
        type: Boolean,
        default: true
      },
      // collapsed control
      collapsedOnClickBrackets: {
        type: Boolean,
        default: true
      },
      // custom formatter for values
      customValueFormatter: {
        type: Function,
        default: null
      },
    },
    data () {
      return {
        isMouseover: false,
        hiddenPaths: jsonFlatten(this.data, this.path).reduce((acc, item) => {
          if ((item.type === 'objectStart' || item.type === 'arrayStart') && item.level === this.deep) {
            return {
              ...acc,
              [item.path]: 1
            }
          }
          return acc
        }, {})
      }
    },
    computed: {
      flatData () {
        let startHiddenItem = null
        const data = jsonFlatten(this.data, this.path).reduce((acc, item) => {
          const isHidden = this.hiddenPaths[item.path]
          if (startHiddenItem && startHiddenItem.path === item.path) {
            const isObject = startHiddenItem.type === 'objectStart'
            const mergeItem = {
              ...startHiddenItem,
              ...item,
              content: isObject ? '{...}' : '[...]',
              type: isObject ? 'objectCollapsed' : 'arrayCollapsed'
            }
            startHiddenItem = null
            return acc.concat(mergeItem)
          } else if (isHidden && !startHiddenItem) {
            startHiddenItem = item
            return acc
          }

          return startHiddenItem ? acc : acc.concat(item)
        }, [])
        console.log(data);
        return data
      },

      selectedPaths: {
        get () {
          if (this.value && this.selectableType === 'single') {
            return [this.value]
          }
          return this.value || []
        },
        set (val) {
          this.$emit('input', val)
        }
      },

      propsError () {
        const error = this.selectableType && !this.selectOnClickNode && !this.showSelectController
        return error ? 'When selectableType is not null, selectOnClickNode and showSelectController cannot be false at the same time, because this will cause the selection to fail.' : ''
      }
    },
    watch: {
      propsError: {
        handler (message) {
          if (message) {
            throw new Error(`[VueJsonPretty] ${message}`)
          }
        },
        immediate: true
      }
    },
    methods: {
      onSelectedChange ({ path }) {
        const type = this.selectableType
        if (type === 'multiple') {
          const index = this.selectedPaths.findIndex(item => item === path)
          const oldVal = [...this.selectedPaths]
          if (index !== -1) {
            this.selectedPaths.splice(index, 1)
          } else {
            this.selectedPaths.push(path)
          }

          this.$emit('change', this.selectedPaths, oldVal)
        } else if (type === 'single') {
          if (this.selectedPaths !== path) {
            const oldVal = this.selectedPaths
            const newVal = path
            this.selectedPaths = newVal
            this.$emit('change', newVal, oldVal)
          }
        }
      },

      onTreeNodeClick ({ content, path }) {
        this.$emit('click', path, content)
      },

      handleMouseover () {
        // 可选择的树|普通展示树, 都支持mouseover
        this.highlightMouseoverNode && (this.isMouseover = true)
      },

      handleMouseout () {
        this.highlightMouseoverNode && (this.isMouseover = false)
      },

      onBracketsClick (collapsed, path) {
        if (collapsed) {
          this.hiddenPaths = {
            ...this.hiddenPaths,
            [path]: 1
          }
        } else {
          const newPaths = {...this.hiddenPaths}
          delete newPaths[path]
          this.hiddenPaths = newPaths
        }
      }
    },
  }
</script>
